diff --git a/clang/lib/Basic/Targets.cpp b/clang/lib/Basic/Targets.cpp
index 636b59fd1..27ee18253 100644
--- a/clang/lib/Basic/Targets.cpp
+++ b/clang/lib/Basic/Targets.cpp
@@ -166,6 +166,8 @@ std::unique_ptr<TargetInfo> AllocateTarget(const llvm::Triple &Triple,
     case llvm::Triple::OpenBSD:
       return std::make_unique<OpenBSDTargetInfo<AArch64leTargetInfo>>(Triple,
                                                                       Opts);
+    case llvm::Triple::Playbit:
+      return std::make_unique<PlaybitTargetInfo<AArch64leTargetInfo>>(Triple, Opts);
     case llvm::Triple::Win32:
       switch (Triple.getEnvironment()) {
       case llvm::Triple::GNU:
@@ -594,6 +596,8 @@ std::unique_ptr<TargetInfo> AllocateTarget(const llvm::Triple &Triple,
       return std::make_unique<RTEMSX86_32TargetInfo>(Triple, Opts);
     case llvm::Triple::NaCl:
       return std::make_unique<NaClTargetInfo<X86_32TargetInfo>>(Triple, Opts);
+    case llvm::Triple::Playbit:
+      return std::make_unique<PlaybitTargetInfo<X86_32TargetInfo>>(Triple, Opts);
     case llvm::Triple::ELFIAMCU:
       return std::make_unique<MCUX86_32TargetInfo>(Triple, Opts);
     case llvm::Triple::Hurd:
@@ -657,6 +661,9 @@ std::unique_ptr<TargetInfo> AllocateTarget(const llvm::Triple &Triple,
       return std::make_unique<HaikuTargetInfo<X86_64TargetInfo>>(Triple, Opts);
     case llvm::Triple::NaCl:
       return std::make_unique<NaClTargetInfo<X86_64TargetInfo>>(Triple, Opts);
+    case llvm::Triple::Playbit:
+      return std::make_unique<PlaybitTargetInfo<X86_64TargetInfo>>(Triple,
+                                                                   Opts);
     case llvm::Triple::PS4:
       return std::make_unique<PS4OSTargetInfo<X86_64TargetInfo>>(Triple, Opts);
     case llvm::Triple::PS5:
@@ -701,6 +708,9 @@ std::unique_ptr<TargetInfo> AllocateTarget(const llvm::Triple &Triple,
       case llvm::Triple::Emscripten:
       return std::make_unique<EmscriptenTargetInfo<WebAssembly32TargetInfo>>(
           Triple, Opts);
+      case llvm::Triple::Playbit:
+        return std::make_unique<PlaybitTargetInfo<WebAssembly32TargetInfo>>(
+          Triple, Opts);
       case llvm::Triple::UnknownOS:
       return std::make_unique<WebAssemblyOSTargetInfo<WebAssembly32TargetInfo>>(
           Triple, Opts);
@@ -719,6 +729,9 @@ std::unique_ptr<TargetInfo> AllocateTarget(const llvm::Triple &Triple,
       case llvm::Triple::Emscripten:
       return std::make_unique<EmscriptenTargetInfo<WebAssembly64TargetInfo>>(
           Triple, Opts);
+      case llvm::Triple::Playbit:
+        return std::make_unique<PlaybitTargetInfo<WebAssembly64TargetInfo>>(
+          Triple, Opts);
       case llvm::Triple::UnknownOS:
       return std::make_unique<WebAssemblyOSTargetInfo<WebAssembly64TargetInfo>>(
           Triple, Opts);
diff --git a/clang/lib/Basic/Targets/OSTargets.h b/clang/lib/Basic/Targets/OSTargets.h
index 8f4331b02..77204dd45 100644
--- a/clang/lib/Basic/Targets/OSTargets.h
+++ b/clang/lib/Basic/Targets/OSTargets.h
@@ -1035,6 +1035,49 @@ public:
   }
 };
 
+// Playbit target, based on LinuxTargetInfo and WASITargetInfo
+template <typename Target>
+class LLVM_LIBRARY_VISIBILITY PlaybitTargetInfo : public OSTargetInfo<Target> {
+protected:
+  void getOSDefines(const LangOptions &Opts, const llvm::Triple &Triple,
+                    MacroBuilder &Builder) const override {
+    if (Triple.isWasm()) {
+      Builder.defineMacro("__wasi__");
+    } else {
+      DefineStd(Builder, "unix", Opts);  // ie. "__unix" and "__unix__"
+      DefineStd(Builder, "linux", Opts); // ie. "__linux" and "__linux__"
+    }
+    Builder.defineMacro("__playbit__", "0000001");
+    if (Opts.POSIXThreads)
+      Builder.defineMacro("_REENTRANT");
+    if (Opts.CPlusPlus)
+      Builder.defineMacro("_GNU_SOURCE");
+    if (this->HasFloat128)
+      Builder.defineMacro("__FLOAT128__");
+  }
+
+public:
+  PlaybitTargetInfo(const llvm::Triple &Triple, const TargetOptions &Opts)
+      : OSTargetInfo<Target>(Triple, Opts) {
+    if (Triple.isWasm()) {
+      this->MCountName = "__mcount";
+      this->TheCXXABI.set(TargetCXXABI::WebAssembly);
+      this->HasFloat128 = true;
+    } else {
+      // from LinuxTargetInfo::LinuxTargetInfo
+      this->WIntType = TargetInfo::UnsignedInt;
+      if (Triple.getArch() == llvm::Triple::x86_64 ||
+          Triple.getArch() == llvm::Triple::x86) {
+        this->HasFloat128 = true;
+      }
+    }
+  }
+
+  const char *getStaticInitSectionSpecifier() const override {
+    return ".text.startup";
+  }
+};
+
 } // namespace targets
 } // namespace clang
 #endif // LLVM_CLANG_LIB_BASIC_TARGETS_OSTARGETS_H
diff --git a/clang/lib/Driver/CMakeLists.txt b/clang/lib/Driver/CMakeLists.txt
index a6bd2d41e..fe9f559bb 100644
--- a/clang/lib/Driver/CMakeLists.txt
+++ b/clang/lib/Driver/CMakeLists.txt
@@ -78,6 +78,7 @@ add_clang_library(clangDriver
   ToolChains/NetBSD.cpp
   ToolChains/OHOS.cpp
   ToolChains/OpenBSD.cpp
+  ToolChains/Playbit.cpp
   ToolChains/PS4CPU.cpp
   ToolChains/RISCVToolchain.cpp
   ToolChains/Solaris.cpp
diff --git a/clang/lib/Driver/Driver.cpp b/clang/lib/Driver/Driver.cpp
index bdbdad936..7b0ebc0a9 100644
--- a/clang/lib/Driver/Driver.cpp
+++ b/clang/lib/Driver/Driver.cpp
@@ -43,6 +43,7 @@
 #include "ToolChains/NetBSD.h"
 #include "ToolChains/OHOS.h"
 #include "ToolChains/OpenBSD.h"
+#include "ToolChains/Playbit.h"
 #include "ToolChains/PPCFreeBSD.h"
 #include "ToolChains/PPCLinux.h"
 #include "ToolChains/PS4CPU.h"
@@ -6267,6 +6268,9 @@ const ToolChain &Driver::getToolChain(const ArgList &Args,
         break;
       }
       break;
+    case llvm::Triple::Playbit:
+      TC = std::make_unique<toolchains::Playbit>(*this, Target, Args);
+      break;
     case llvm::Triple::PS4:
       TC = std::make_unique<toolchains::PS4CPU>(*this, Target, Args);
       break;
diff --git a/clang/lib/Driver/ToolChains/Playbit.cpp b/clang/lib/Driver/ToolChains/Playbit.cpp
new file mode 100644
index 000000000..eb4b0e43d
--- /dev/null
+++ b/clang/lib/Driver/ToolChains/Playbit.cpp
@@ -0,0 +1,554 @@
+//===--- Playbit.cpp - Playbit ToolChain Implementations --------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "Playbit.h"
+#include "WebAssembly.h"
+#include "Arch/ARM.h"
+#include "CommonArgs.h"
+#include "clang/Config/config.h"
+#include "clang/Driver/Compilation.h"
+#include "clang/Driver/Driver.h"
+#include "clang/Driver/DriverDiagnostic.h"
+#include "clang/Driver/Options.h"
+#include "clang/Driver/SanitizerArgs.h"
+#include "llvm/Option/ArgList.h"
+#include "llvm/ProfileData/InstrProf.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/Path.h"
+#include "llvm/Support/VirtualFileSystem.h"
+#include "llvm/Support/ScopedPrinter.h"
+
+#include <iostream>
+
+using namespace clang::driver;
+using namespace clang::driver::toolchains;
+using namespace clang::driver::tools;
+using namespace clang;
+using namespace llvm::opt;
+using namespace clang::driver::tools::arm;
+
+using tools::addMultilibFlag;
+using tools::addPathIfExists;
+using llvm::sys::path::parent_path;
+
+
+static std::string fspath(const std::initializer_list<std::string> &IL) {
+  SmallString<128> P;
+  for (const auto &S : IL)
+    llvm::sys::path::append(P, S);
+  return static_cast<std::string>(P.str());
+}
+
+
+// based on fuchsia::Linker::ConstructJob
+void playbit::Linker::ConstructJob(Compilation &C, const JobAction &JA,
+                                   const InputInfo &Output,
+                                   const InputInfoList &Inputs,
+                                   const ArgList &Args,
+                                   const char *LinkingOutput) const {
+  const toolchains::Playbit &ToolChain =
+      static_cast<const toolchains::Playbit &>(getToolChain());
+  const Driver &D = ToolChain.getDriver();
+
+  const llvm::Triple &Triple = ToolChain.getEffectiveTriple();
+
+  ArgStringList CmdArgs;
+
+  // Silence warning for "clang -g foo.o -o foo"
+  Args.ClaimAllArgs(options::OPT_g_Group);
+  // and "clang -emit-llvm foo.o -o foo"
+  Args.ClaimAllArgs(options::OPT_emit_llvm);
+  // and for "clang -w foo.o -o foo". Other warning options are already
+  // handled somewhere else.
+  Args.ClaimAllArgs(options::OPT_w);
+
+  CmdArgs.push_back("-z");
+  CmdArgs.push_back("max-page-size=4096");
+
+  CmdArgs.push_back("-z");
+  CmdArgs.push_back("now");
+
+  CmdArgs.push_back("-z");
+  CmdArgs.push_back("relro");
+
+  //CmdArgs.push_back("--enable-new-dtags");
+
+  const char *Exec = Args.MakeArgString(ToolChain.GetLinkerPath());
+  if (llvm::sys::path::filename(Exec).equals_insensitive("ld.lld") ||
+      llvm::sys::path::stem(Exec).equals_insensitive("ld.lld")) {
+    CmdArgs.push_back("-z");
+    CmdArgs.push_back("rodynamic");
+    CmdArgs.push_back("-z");
+    CmdArgs.push_back("separate-loadable-segments");
+    CmdArgs.push_back("-z");
+    CmdArgs.push_back("rel");
+    CmdArgs.push_back("--pack-dyn-relocs=relr");
+  }
+
+  if (!ToolChain.SysRoot.empty())
+    CmdArgs.push_back(Args.MakeArgString("--sysroot=" + ToolChain.SysRoot));
+
+  bool isPIE;
+  if (Args.hasArg(options::OPT_shared) ||
+      Args.hasArg(options::OPT_static) ||
+      Args.hasArg(options::OPT_r) ||
+      Args.hasArg(options::OPT_static_pie) ) {
+    isPIE = false;
+  } else {
+    Arg *A = Args.getLastArg(options::OPT_pie, options::OPT_no_pie, options::OPT_nopie);
+    if (A) {
+      isPIE = A->getOption().matches(options::OPT_pie);
+    } else {
+      isPIE = ToolChain.isPIEDefault(Args);
+    }
+  }
+  if (isPIE)
+    CmdArgs.push_back("-pie");
+
+  if (Args.hasArg(options::OPT_static_pie)) {
+    CmdArgs.push_back("-static");
+    CmdArgs.push_back("-pie");
+    CmdArgs.push_back("--no-dynamic-linker");
+    CmdArgs.push_back("-z");
+    CmdArgs.push_back("text");
+  }
+
+  if (Args.hasArg(options::OPT_s))
+    CmdArgs.push_back("-s");
+
+  if (Args.hasArg(options::OPT_r)) {
+    CmdArgs.push_back("-r");
+  } else {
+    CmdArgs.push_back("--build-id");
+    CmdArgs.push_back("--hash-style=gnu");
+  }
+
+  if (ToolChain.getArch() == llvm::Triple::aarch64) {
+    CmdArgs.push_back("--execute-only");
+    std::string CPU = getCPUName(D, Args, Triple);
+    if (CPU.empty() || CPU == "generic" || CPU == "cortex-a53")
+      CmdArgs.push_back("--fix-cortex-a53-843419");
+  }
+
+  CmdArgs.push_back("--eh-frame-hdr");
+
+  if (Args.hasArg(options::OPT_static)) {
+    CmdArgs.push_back("-Bstatic"); // == -static
+  } else {
+    if (Args.hasArg(options::OPT_rdynamic))
+      CmdArgs.push_back("-export-dynamic");
+    if (Args.hasArg(options::OPT_shared))
+      CmdArgs.push_back("-shared");
+    if (!Args.hasArg(options::OPT_shared) &&
+        !Args.hasArg(options::OPT_r) &&
+        !Args.hasArg(options::OPT_static_pie)) {
+      // note: we ignore D.DyldPrefix (set with --dyld-prefix=) since the user can
+      // override -dynamic-linker with -Wl,-dynamic-linker,/some/path
+      CmdArgs.push_back("-dynamic-linker");
+      CmdArgs.push_back(Args.MakeArgString("/lib/ld.so.1"));
+    }
+  }
+
+  if (ToolChain.getArch() == llvm::Triple::riscv64)
+    CmdArgs.push_back("-X");
+
+  CmdArgs.push_back("-o");
+  CmdArgs.push_back(Output.getFilename());
+
+  // C runtime files
+  // musl startfiles:
+  //   crt1.o  [exe] position-dependent _start
+  //   rcrt1.o [exe] position-independent _start, static libc
+  //   Scrt1.o [exe] position-independent _start, shared libc
+  //   crti.o  [exe, shlib] function prologs for the .init and .fini sections
+  //   crtn.o  [exe, shlib] function epilogs for the .init/.fini sections
+  //   note: musl has no crt0
+  //   linking order: crt1 crti [-L paths] [objects] [C libs] crtn
+  //   See https://www.openwall.com/lists/musl/2015/06/01/12 (re. rcrt1.o)
+  //   See https://dev.gentoo.org/~vapier/crt.txt
+  bool hasCRTFiles =
+    !Args.hasArg(options::OPT_nostdlib, options::OPT_nostartfiles, options::OPT_r);
+  if (hasCRTFiles) {
+    if (!Args.hasArg(options::OPT_shared)) {
+      const char* crt1;
+      if (Args.hasArg(options::OPT_static_pie)) crt1 = "rcrt1.o";
+      else if (isPIE)                           crt1 = "Scrt1.o";
+      else                                      crt1 = "crt1.o";
+      CmdArgs.push_back(Args.MakeArgString(ToolChain.GetFilePath(crt1)));
+    }
+    CmdArgs.push_back(Args.MakeArgString(ToolChain.GetFilePath("crti.o")));
+  }
+
+  Args.AddAllArgs(CmdArgs, options::OPT_L);
+  Args.AddAllArgs(CmdArgs, options::OPT_u);
+
+  ToolChain.AddFilePathLibArgs(Args, CmdArgs);
+
+  if (D.isUsingLTO()) {
+    assert(!Inputs.empty() && "Must have at least one input.");
+    addLTOOptions(ToolChain, Args, CmdArgs, Output, Inputs[0],
+                  D.getLTOMode() == LTOK_Thin);
+  }
+
+  addLinkerCompressDebugSectionsOption(ToolChain, Args, CmdArgs);
+  AddLinkerInputs(ToolChain, Inputs, Args, CmdArgs, JA);
+
+  if (!Args.hasArg(options::OPT_nostdlib, options::OPT_nodefaultlibs, options::OPT_r)) {
+    if (D.CCCIsCXX()) {
+      if (ToolChain.ShouldLinkCXXStdlib(Args)) {
+        bool OnlyLibstdcxxStatic = Args.hasArg(options::OPT_static_libstdcxx) &&
+                                   !Args.hasArg(options::OPT_static);
+        CmdArgs.push_back("--push-state");
+        CmdArgs.push_back("--as-needed");
+        if (OnlyLibstdcxxStatic)
+          CmdArgs.push_back("-Bstatic");
+        ToolChain.AddCXXStdlibLibArgs(Args, CmdArgs);
+        if (OnlyLibstdcxxStatic)
+          CmdArgs.push_back("-Bdynamic");
+        CmdArgs.push_back("-lm");
+        CmdArgs.push_back("--pop-state");
+      }
+    }
+
+    bool NeedsSanitizerDeps = addSanitizerRuntimes(ToolChain, Args, CmdArgs);
+    if (NeedsSanitizerDeps)
+      linkSanitizerRuntimeDeps(ToolChain, CmdArgs);
+
+    bool NeedsXRayDeps = addXRayRuntime(ToolChain, Args, CmdArgs);
+    if (NeedsXRayDeps)
+      linkXRayRuntimeDeps(ToolChain, CmdArgs);
+
+    ToolChain.addProfileRTLibs(Args, CmdArgs);
+
+    AddRunTimeLibs(ToolChain, D, CmdArgs, Args);
+
+    if (Args.hasArg(options::OPT_pthread) ||
+        Args.hasArg(options::OPT_pthreads))
+      CmdArgs.push_back("-lpthread");
+
+    if (Args.hasArg(options::OPT_fsplit_stack))
+      CmdArgs.push_back("--wrap=pthread_create");
+
+    if (!Args.hasArg(options::OPT_nolibc))
+      CmdArgs.push_back("-lc");
+  }
+
+  if (hasCRTFiles)
+    CmdArgs.push_back(Args.MakeArgString(ToolChain.GetFilePath("crtn.o")));
+
+  Args.AddAllArgs(CmdArgs, options::OPT_T);
+
+  C.addCommand(std::make_unique<Command>(JA, *this,
+                                         ResponseFileSupport::AtFileCurCP(),
+                                         Exec, CmdArgs, Inputs, Output));
+}
+
+
+// based on fuchsia::StaticLibTool::ConstructJob
+void playbit::StaticLibTool::ConstructJob(Compilation &C, const JobAction &JA,
+                                          const InputInfo &Output,
+                                          const InputInfoList &Inputs,
+                                          const ArgList &Args,
+                                          const char *LinkingOutput) const {
+  const Driver &D = getToolChain().getDriver();
+
+  // Silence warning for "clang -g foo.o -o foo"
+  Args.ClaimAllArgs(options::OPT_g_Group);
+  // and "clang -emit-llvm foo.o -o foo"
+  Args.ClaimAllArgs(options::OPT_emit_llvm);
+  // and for "clang -w foo.o -o foo". Other warning options are already
+  // handled somewhere else.
+  Args.ClaimAllArgs(options::OPT_w);
+  // Silence warnings when linking C code with a C++ '-stdlib' argument.
+  Args.ClaimAllArgs(options::OPT_stdlib_EQ);
+
+  // ar tool command "llvm-ar <options> <output_file> <input_files>".
+  ArgStringList CmdArgs;
+  // Create and insert file members with a deterministic index.
+  CmdArgs.push_back("rcsD");
+  CmdArgs.push_back(Output.getFilename());
+
+  for (const auto &II : Inputs) {
+    if (II.isFilename())
+      CmdArgs.push_back(II.getFilename());
+  }
+
+  // Delete old output archive file if it already exists before generating a new
+  // archive file.
+  const char *OutputFileName = Output.getFilename();
+  if (Output.isFilename() && llvm::sys::fs::exists(OutputFileName)) {
+    if (std::error_code EC = llvm::sys::fs::remove(OutputFileName)) {
+      D.Diag(diag::err_drv_unable_to_remove_file) << EC.message();
+      return;
+    }
+  }
+
+  const char *Exec = Args.MakeArgString(getToolChain().GetStaticLibToolPath());
+  C.addCommand(std::make_unique<Command>(JA, *this,
+                                         ResponseFileSupport::AtFileCurCP(),
+                                         Exec, CmdArgs, Inputs, Output));
+}
+
+
+/// Playbit Toolchain
+Playbit::Playbit(const Driver &D, const llvm::Triple &targetTriple, const ArgList &Args)
+    : ToolChain(D, targetTriple, Args) {
+
+  // Note: D.getInstalledDir() returns logical path; it does not resolve symlinks.
+  // I.e. with clang installed at /foo/bar/clang and symlinked at /cat/clang,
+  // D.getInstalledDir() == /cat, D.getClangProgramPath() == /foo/bar/clang
+  std::string exedir = std::string(parent_path(D.getClangProgramPath()));
+  std::string sdkDir = std::string(parent_path(exedir));
+  #if 0
+    std::cout << "[pb] exedir: " << exedir << std::endl;
+    std::cout << "[pb] sdkDir: " << sdkDir << std::endl;
+    std::cout << "[pb] D.Dir: " << std::string(D.Dir) << std::endl;
+    std::cout << "[pb] driver.SysRoot: " << D.SysRoot << std::endl;
+    std::cout << "[pb] triple: " << getTriple().str() << std::endl;
+  #endif
+
+  // compute sysroot, respecting explicit --sysroot= argument
+  if (D.SysRoot.empty()) {
+    SysRoot = fspath({ sdkDir, "sysroot-" + getTriple().getArchName().str() });
+  } else {
+    SysRoot = D.SysRoot;
+  }
+  // std::cout << "[pb] effective sysroot: \"" << SysRoot << "\"" << std::endl;
+
+  // when searching for tools like ld.lld, look in these directories
+  getProgramPaths().push_back(exedir);
+  // D.Dir: path the driver executable was in, as invoked from the command line
+  if (D.getInstalledDir() != D.Dir)
+    getProgramPaths().push_back(D.Dir);
+
+  // setup search paths
+  getFilePaths().clear(); // always empty; just in case it changes in future llvm
+  getLibraryPaths().clear(); // always empty; just in case it changes in future llvm
+  std::string lib_suffix = getTriple().getArchName().str() + "-playbit";
+  std::string compiler_rt_lib_path = fspath({
+    D.ResourceDir, "lib", lib_suffix });
+  // std::cout << "[pb] compiler_rt_lib_path: " << compiler_rt_lib_path << std::endl;
+  if (getVFS().exists(compiler_rt_lib_path)) {
+    // std::cout << "  found" << std::endl;
+    getFilePaths().push_back(compiler_rt_lib_path);
+    getLibraryPaths().push_back(compiler_rt_lib_path);
+  }
+  getFilePaths().push_back(fspath({ SysRoot, "lib" }));
+
+  // Default linker. Can be overridden with --ld-path= or -fuse-ld=
+  // Absolute path to reduce I/O from ToolChain::GetLinkerPath & Driver::GetProgramPath
+  DefaultLinker = exedir + (getTriple().isWasm() ? "/wasm-ld" : "/ld.lld");
+}
+
+
+/// Following the conventions in https://wiki.debian.org/Multiarch/Tuples,
+/// we remove the vendor field to form the multiarch triple.
+std::string Playbit::getMultiarchTriple(const llvm::Triple &T) const {
+  // printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
+  return (T.getArchName() + "-" + T.getOSAndEnvironmentName()).str();
+}
+
+
+std::string Playbit::getMultiarchTriple(const Driver &D,
+                                        const llvm::Triple &TargetTriple,
+                                        StringRef SysRoot) const {
+  return getMultiarchTriple(TargetTriple);
+}
+
+
+bool Playbit::isPIEDefault(const llvm::opt::ArgList &Args) const {
+  // true for native targets, false for wasm
+  return !getTriple().isWasm();
+}
+
+
+bool Playbit::hasBlocksRuntime() const {
+  return !getTriple().isWasm();
+}
+
+
+Tool *Playbit::buildAssembler() const {
+  return new tools::gnutools::Assembler(*this);
+}
+
+
+Tool* Playbit::buildLinker() const {
+  if (getTriple().isWasm())
+    return new tools::wasm::Linker(*this);
+
+  // Note: gnutools::Linker requires the driver to be a subclass of Generic_ELF.
+  // This is not conveyed in the type signature (it can't; it's complicated.)
+  // Internally, gnutools::Linker::ConstructJob performs a cast to Generic_ELF.
+  // We will get hard-to-debug crash from vtable dispatch if this is not Generic_ELF.
+  //return new tools::gnutools::Linker(*this);
+
+  return new tools::playbit::Linker(*this);
+}
+
+
+Tool *Playbit::buildStaticLibTool() const {
+  assert(!getTriple().isWasm());
+  return new tools::playbit::StaticLibTool(*this);
+}
+
+
+void Playbit::addClangTargetOptions(const ArgList &DriverArgs,
+                                    ArgStringList &CC1Args,
+                                    Action::OffloadKind) const {
+  // based on Generic_ELF::addClangTargetOptions
+  if (!DriverArgs.hasFlag(options::OPT_fuse_init_array,
+                          options::OPT_fno_use_init_array, true))
+    CC1Args.push_back("-fno-use-init-array");
+}
+
+
+void Playbit::AddClangSystemIncludeArgs(const ArgList &DriverArgs,
+                                        ArgStringList &CC1Args) const {
+  const Driver &D = getDriver();
+  //const llvm::Triple &Triple = getTriple();
+
+  // don't add any search paths if -nostdinc is set
+  if (DriverArgs.hasArg(options::OPT_nostdinc))
+    return;
+
+  // add -isystem<sdkDir>/lib/clang/include (unless -nobuiltininc is set)
+  if (!DriverArgs.hasArg(options::OPT_nobuiltininc)) {
+    SmallString<128> P(D.ResourceDir);
+    llvm::sys::path::append(P, "include");
+    addSystemInclude(DriverArgs, CC1Args, P);
+  }
+
+  // don't add standard-library search paths if -nostdlibinc is set
+  if (DriverArgs.hasArg(options::OPT_nostdlibinc))
+    return;
+
+  // Check for configure-time C include directories.
+  // std::cout << "[pb] C_INCLUDE_DIRS: \"" << C_INCLUDE_DIRS << "\"" << std::endl;
+  StringRef CIncludeDirs(C_INCLUDE_DIRS);
+  if (CIncludeDirs != "") {
+    SmallVector<StringRef, 5> dirs;
+    CIncludeDirs.split(dirs, ":");
+    for (StringRef dir : dirs) {
+      if (llvm::sys::path::is_absolute(dir)) {
+        addExternCSystemInclude(DriverArgs, CC1Args, dir);
+      } else {
+        addExternCSystemInclude(
+          DriverArgs, CC1Args, fspath({ SysRoot, std::string(dir) }));
+      }
+    }
+    return;
+  }
+
+  addExternCSystemInclude(DriverArgs, CC1Args, SysRoot + "/include");
+}
+
+
+void Playbit::AddClangCXXStdlibIncludeArgs(const ArgList &DriverArgs,
+                                        ArgStringList &CC1Args) const {
+  if (DriverArgs.hasArg(options::OPT_nostdlibinc) ||
+      DriverArgs.hasArg(options::OPT_nostdincxx))
+    return;
+
+  std::string incPath = fspath({SysRoot, "include", "c++", "v1"});
+  if (getVFS().exists(incPath)) {
+    // SDK headers
+    addSystemInclude(DriverArgs, CC1Args, incPath);
+  } else {
+    // fall back to system headers. D.Dir == dirname(clang_argv[0])
+    std::string incPath = fspath({getDriver().Dir, "..", "include", "c++", "v1"});
+    if (getVFS().exists(incPath))
+      addSystemInclude(DriverArgs, CC1Args, incPath);
+  }
+}
+
+
+void Playbit::AddCXXStdlibLibArgs(const ArgList &DriverArgs,
+                                  ArgStringList &CmdArgs) const {
+  if (DriverArgs.hasArg(options::OPT_nostdlib) ||
+      DriverArgs.hasArg(options::OPT_nostdlibxx))
+    return;
+  CmdArgs.push_back("-lc++");
+  CmdArgs.push_back("-lc++abi");
+  CmdArgs.push_back("-lunwind");
+}
+
+
+std::string Playbit::getCompilerRT(const ArgList &Args, StringRef Component,
+                                   FileType Type) const {
+  // printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
+  SmallString<128> Path(getDriver().ResourceDir);
+  llvm::sys::path::append(Path, "lib", getMultiarchTriple(getTriple()));
+  const char *Prefix = Type == ToolChain::FT_Object ? "" : "lib";
+  const char *Suffix;
+  switch (Type) {
+  case ToolChain::FT_Object:
+    Suffix = ".o";
+    break;
+  case ToolChain::FT_Static:
+    Suffix = ".a";
+    break;
+  case ToolChain::FT_Shared:
+    Suffix = ".so";
+    break;
+  }
+  llvm::sys::path::append(
+      Path, Prefix + Twine("clang_rt.") + Component + Suffix);
+  return static_cast<std::string>(Path.str());
+}
+
+
+SanitizerMask Playbit::getSupportedSanitizers() const {
+  // printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
+  SanitizerMask Res = ToolChain::getSupportedSanitizers();
+  if (getTriple().isWasm()) {
+    // -fsanitize=function places two words before the function label (unsupported)
+    Res &= ~SanitizerKind::Function;
+  } else {
+    // x86_64 or aarch64 (based on Linux::getSupportedSanitizers)
+    Res |= SanitizerKind::Address;
+    Res |= SanitizerKind::PointerCompare;
+    Res |= SanitizerKind::PointerSubtract;
+    Res |= SanitizerKind::Fuzzer;
+    Res |= SanitizerKind::FuzzerNoLink;
+    Res |= SanitizerKind::KernelAddress;
+    Res |= SanitizerKind::Memory;
+    Res |= SanitizerKind::Vptr;
+    Res |= SanitizerKind::SafeStack;
+    Res |= SanitizerKind::DataFlow;
+    Res |= SanitizerKind::Leak;
+    Res |= SanitizerKind::Thread;
+    if (getTriple().getArch() == llvm::Triple::x86_64)
+      Res |= SanitizerKind::KernelMemory;
+    // Res |= SanitizerKind::Scudo;
+    Res |= SanitizerKind::HWAddress;
+    Res |= SanitizerKind::KernelHWAddress;
+  }
+  return Res;
+}
+
+
+// TODO: Make a base class for Linux and Playbit and move this there.
+void Playbit::addProfileRTLibs(const llvm::opt::ArgList &Args,
+                             llvm::opt::ArgStringList &CmdArgs) const {
+  // printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
+  // Add linker option -u__llvm_profile_runtime to cause runtime
+  // initialization module to be linked in.
+  if (needsProfileRT(Args))
+    CmdArgs.push_back(Args.MakeArgString(
+        Twine("-u", llvm::getInstrProfRuntimeHookVarName())));
+  ToolChain::addProfileRTLibs(Args, CmdArgs);
+}
+
+
+ToolChain::UnwindLibType Playbit::GetUnwindLibType(
+    const llvm::opt::ArgList &Args) const {
+  // printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
+  if (Args.getLastArg(options::OPT_unwindlib_EQ))
+    return ToolChain::GetUnwindLibType(Args);
+  return getTriple().isWasm() ? ToolChain::UNW_None : ToolChain::UNW_CompilerRT;
+}
diff --git a/clang/lib/Driver/ToolChains/Playbit.h b/clang/lib/Driver/ToolChains/Playbit.h
new file mode 100644
index 000000000..321518b1d
--- /dev/null
+++ b/clang/lib/Driver/ToolChains/Playbit.h
@@ -0,0 +1,126 @@
+//===--- Playbit.h - Playbit ToolChain Implementations --------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_Playbit_H
+#define LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_Playbit_H
+
+#include "clang/Driver/Tool.h"
+#include "clang/Driver/ToolChain.h"
+
+namespace clang {
+namespace driver {
+
+namespace tools {
+namespace playbit {
+
+class LLVM_LIBRARY_VISIBILITY StaticLibTool : public Tool {
+public:
+  StaticLibTool(const ToolChain &TC)
+      : Tool("playbit::StaticLibTool", "llvm-ar", TC) {}
+
+  bool hasIntegratedCPP() const override { return false; }
+  bool isLinkJob() const override { return true; }
+
+  void ConstructJob(Compilation &C, const JobAction &JA,
+                    const InputInfo &Output, const InputInfoList &Inputs,
+                    const llvm::opt::ArgList &TCArgs,
+                    const char *LinkingOutput) const override;
+};
+
+class LLVM_LIBRARY_VISIBILITY Linker : public Tool {
+public:
+  Linker(const ToolChain &TC) : Tool("playbit::Linker", "ld.lld", TC) {}
+
+  bool hasIntegratedCPP() const override { return false; }
+  bool isLinkJob() const override { return true; }
+
+  void ConstructJob(Compilation &C, const JobAction &JA,
+                    const InputInfo &Output, const InputInfoList &Inputs,
+                    const llvm::opt::ArgList &TCArgs,
+                    const char *LinkingOutput) const override;
+};
+
+} // end namespace playbit
+} // end namespace tools
+
+namespace toolchains {
+
+class LLVM_LIBRARY_VISIBILITY Playbit : public ToolChain {
+  friend class clang::driver::tools::playbit::Linker;
+  std::string SysRoot;
+  std::string DefaultLinker;
+public:
+  Playbit(const Driver &D, const llvm::Triple &Triple,
+          const llvm::opt::ArgList &Args);
+
+  bool HasNativeLLVMSupport() const override { return true; }
+  bool IsMathErrnoDefault() const override { return false; }
+  bool isPICDefault() const override { return false; }
+  bool isPIEDefault(const llvm::opt::ArgList &Args) const override;
+  bool isPICDefaultForced() const override { return false; }
+  bool hasBlocksRuntime() const override;
+  bool SupportsProfiling() const override { return !getTriple().isWasm(); }
+  unsigned GetDefaultDwarfVersion() const override {
+    return getTriple().isWasm() ? 4 : 5;
+  }
+
+  UnwindLibType GetUnwindLibType(const llvm::opt::ArgList &Args) const override;
+  UnwindLibType GetDefaultUnwindLibType() const override { return UNW_CompilerRT; }
+
+  RuntimeLibType GetDefaultRuntimeLibType() const override {
+    return ToolChain::RLT_CompilerRT;
+  }
+  CXXStdlibType GetDefaultCXXStdlibType() const override {
+    return ToolChain::CST_Libcxx;
+  }
+  RuntimeLibType GetRuntimeLibType(const llvm::opt::ArgList &Args) const override {
+    return ToolChain::RLT_CompilerRT;
+  }
+  CXXStdlibType GetCXXStdlibType(const llvm::opt::ArgList &Args) const override {
+    return ToolChain::CST_Libcxx;
+  }
+  bool IsAArch64OutlineAtomicsDefault(const llvm::opt::ArgList &Args) const override {
+    // Outline atomics for AArch64 are supported by compiler-rt
+    return true;
+  }
+
+  void addClangTargetOptions(const llvm::opt::ArgList &DriverArgs,
+                             llvm::opt::ArgStringList &CC1Args,
+                             Action::OffloadKind DeviceOffloadKind) const override;
+
+  void AddClangSystemIncludeArgs(const llvm::opt::ArgList &DriverArgs,
+                                 llvm::opt::ArgStringList &CC1Args) const override;
+  void AddClangCXXStdlibIncludeArgs(const llvm::opt::ArgList &DriverArgs,
+                                    llvm::opt::ArgStringList &CC1Args) const override;
+  void AddCXXStdlibLibArgs(const llvm::opt::ArgList &Args,
+                           llvm::opt::ArgStringList &CmdArgs) const override;
+
+  std::string computeSysRoot() const override { return SysRoot; }
+  std::string getCompilerRT(const llvm::opt::ArgList &Args, StringRef Component,
+                            FileType Type = ToolChain::FT_Static) const override;
+  SanitizerMask getSupportedSanitizers() const override;
+  const char *getDefaultLinker() const override { return DefaultLinker.c_str(); }
+
+  Tool *buildAssembler() const override;
+  Tool *buildLinker() const override;
+  Tool *buildStaticLibTool() const override;
+
+protected:
+  std::string getMultiarchTriple(const llvm::Triple &T) const;
+  std::string getMultiarchTriple(const Driver &D,
+                                 const llvm::Triple &TargetTriple,
+                                 StringRef SysRoot) const override;
+  void addProfileRTLibs(const llvm::opt::ArgList &Args,
+                             llvm::opt::ArgStringList &CmdArgs) const override;
+};
+
+} // end namespace toolchains
+} // end namespace driver
+} // end namespace clang
+
+#endif // LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_Playbit_H
diff --git a/compiler-rt/lib/builtins/CMakeLists.txt b/compiler-rt/lib/builtins/CMakeLists.txt
index d62fa0432..73411382d 100644
--- a/compiler-rt/lib/builtins/CMakeLists.txt
+++ b/compiler-rt/lib/builtins/CMakeLists.txt
@@ -898,7 +898,7 @@ endif()
 # TODO: COMPILER_RT_BUILD_CRT used to be a cached variable so we need to unset
 # it first so cmake_dependent_option can set the local variable of the same
 # name. This statement can be removed in the future.
-unset(COMPILER_RT_BUILD_CRT CACHE)
+#unset(COMPILER_RT_BUILD_CRT CACHE)
 
 cmake_dependent_option(COMPILER_RT_BUILD_CRT "Build crtbegin.o/crtend.o" ON "COMPILER_RT_HAS_CRT" OFF)
 
diff --git a/llvm/include/llvm/TargetParser/Triple.h b/llvm/include/llvm/TargetParser/Triple.h
index 79ccd644a..f97a2b1b9 100644
--- a/llvm/include/llvm/TargetParser/Triple.h
+++ b/llvm/include/llvm/TargetParser/Triple.h
@@ -225,7 +225,8 @@ public:
     Emscripten,
     ShaderModel, // DirectX ShaderModel
     LiteOS,
-    LastOSType = LiteOS
+    Playbit,
+    LastOSType = Playbit
   };
   enum EnvironmentType {
     UnknownEnvironment,
diff --git a/llvm/lib/TargetParser/Triple.cpp b/llvm/lib/TargetParser/Triple.cpp
index a3d6a06af..c8a5d0802 100644
--- a/llvm/lib/TargetParser/Triple.cpp
+++ b/llvm/lib/TargetParser/Triple.cpp
@@ -245,6 +245,7 @@ StringRef Triple::getOSTypeName(OSType Kind) {
   case ZOS: return "zos";
   case ShaderModel: return "shadermodel";
   case LiteOS: return "liteos";
+  case Playbit: return "playbit";
   }
 
   llvm_unreachable("Invalid OSType");
@@ -601,6 +602,7 @@ static Triple::OSType parseOS(StringRef OSName) {
     .StartsWith("cuda", Triple::CUDA)
     .StartsWith("nvcl", Triple::NVCL)
     .StartsWith("amdhsa", Triple::AMDHSA)
+    .StartsWith("playbit", Triple::Playbit)
     .StartsWith("ps4", Triple::PS4)
     .StartsWith("ps5", Triple::PS5)
     .StartsWith("elfiamcu", Triple::ELFIAMCU)
