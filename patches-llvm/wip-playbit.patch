diff --git a/clang/lib/Basic/Targets.cpp b/clang/lib/Basic/Targets.cpp
index 636b59fd1..9fa3cf9ef 100644
--- a/clang/lib/Basic/Targets.cpp
+++ b/clang/lib/Basic/Targets.cpp
@@ -166,6 +166,8 @@ std::unique_ptr<TargetInfo> AllocateTarget(const llvm::Triple &Triple,
     case llvm::Triple::OpenBSD:
       return std::make_unique<OpenBSDTargetInfo<AArch64leTargetInfo>>(Triple,
                                                                       Opts);
+    case llvm::Triple::Playbit:
+      return std::make_unique<PlaybitTargetInfo<AArch64leTargetInfo>>(Triple, Opts);
     case llvm::Triple::Win32:
       switch (Triple.getEnvironment()) {
       case llvm::Triple::GNU:
@@ -594,6 +596,8 @@ std::unique_ptr<TargetInfo> AllocateTarget(const llvm::Triple &Triple,
       return std::make_unique<RTEMSX86_32TargetInfo>(Triple, Opts);
     case llvm::Triple::NaCl:
       return std::make_unique<NaClTargetInfo<X86_32TargetInfo>>(Triple, Opts);
+    case llvm::Triple::Playbit:
+      return std::make_unique<PlaybitTargetInfo<X86_32TargetInfo>>(Triple, Opts);
     case llvm::Triple::ELFIAMCU:
       return std::make_unique<MCUX86_32TargetInfo>(Triple, Opts);
     case llvm::Triple::Hurd:
@@ -657,6 +661,9 @@ std::unique_ptr<TargetInfo> AllocateTarget(const llvm::Triple &Triple,
       return std::make_unique<HaikuTargetInfo<X86_64TargetInfo>>(Triple, Opts);
     case llvm::Triple::NaCl:
       return std::make_unique<NaClTargetInfo<X86_64TargetInfo>>(Triple, Opts);
+    case llvm::Triple::Playbit:
+      return std::make_unique<PlaybitTargetInfo<X86_64TargetInfo>>(Triple,
+                                                                   Opts);
     case llvm::Triple::PS4:
       return std::make_unique<PS4OSTargetInfo<X86_64TargetInfo>>(Triple, Opts);
     case llvm::Triple::PS5:
@@ -701,6 +708,9 @@ std::unique_ptr<TargetInfo> AllocateTarget(const llvm::Triple &Triple,
       case llvm::Triple::Emscripten:
       return std::make_unique<EmscriptenTargetInfo<WebAssembly32TargetInfo>>(
           Triple, Opts);
+      case llvm::Triple::Playbit:
+        return std::make_unique<PlaybitTargetInfo<WebAssembly32TargetInfo>>(
+          Triple, Opts);
       case llvm::Triple::UnknownOS:
       return std::make_unique<WebAssemblyOSTargetInfo<WebAssembly32TargetInfo>>(
           Triple, Opts);
@@ -719,6 +729,9 @@ std::unique_ptr<TargetInfo> AllocateTarget(const llvm::Triple &Triple,
       case llvm::Triple::Emscripten:
       return std::make_unique<EmscriptenTargetInfo<WebAssembly64TargetInfo>>(
           Triple, Opts);
+      case llvm::Triple::Playbit:
+        return std::make_unique<PlaybitTargetInfo<WebAssembly64TargetInfo>>(
+          Triple, Opts);
       case llvm::Triple::UnknownOS:
       return std::make_unique<WebAssemblyOSTargetInfo<WebAssembly64TargetInfo>>(
           Triple, Opts);
@@ -777,6 +790,7 @@ TargetInfo::CreateTargetInfo(DiagnosticsEngine &Diags,
   // Construct the target
   std::unique_ptr<TargetInfo> Target = AllocateTarget(Triple, *Opts);
   if (!Target) {
+    printf("[pb] err_target_unknown_triple (%s:%d)\n", __FILE__, __LINE__);
     Diags.Report(diag::err_target_unknown_triple) << Triple.str();
     return nullptr;
   }
diff --git a/clang/lib/Basic/Targets/OSTargets.h b/clang/lib/Basic/Targets/OSTargets.h
index 8f4331b02..77204dd45 100644
--- a/clang/lib/Basic/Targets/OSTargets.h
+++ b/clang/lib/Basic/Targets/OSTargets.h
@@ -1035,6 +1035,49 @@ public:
   }
 };
 
+// Playbit target, based on LinuxTargetInfo and WASITargetInfo
+template <typename Target>
+class LLVM_LIBRARY_VISIBILITY PlaybitTargetInfo : public OSTargetInfo<Target> {
+protected:
+  void getOSDefines(const LangOptions &Opts, const llvm::Triple &Triple,
+                    MacroBuilder &Builder) const override {
+    if (Triple.isWasm()) {
+      Builder.defineMacro("__wasi__");
+    } else {
+      DefineStd(Builder, "unix", Opts);  // ie. "__unix" and "__unix__"
+      DefineStd(Builder, "linux", Opts); // ie. "__linux" and "__linux__"
+    }
+    Builder.defineMacro("__playbit__", "0000001");
+    if (Opts.POSIXThreads)
+      Builder.defineMacro("_REENTRANT");
+    if (Opts.CPlusPlus)
+      Builder.defineMacro("_GNU_SOURCE");
+    if (this->HasFloat128)
+      Builder.defineMacro("__FLOAT128__");
+  }
+
+public:
+  PlaybitTargetInfo(const llvm::Triple &Triple, const TargetOptions &Opts)
+      : OSTargetInfo<Target>(Triple, Opts) {
+    if (Triple.isWasm()) {
+      this->MCountName = "__mcount";
+      this->TheCXXABI.set(TargetCXXABI::WebAssembly);
+      this->HasFloat128 = true;
+    } else {
+      // from LinuxTargetInfo::LinuxTargetInfo
+      this->WIntType = TargetInfo::UnsignedInt;
+      if (Triple.getArch() == llvm::Triple::x86_64 ||
+          Triple.getArch() == llvm::Triple::x86) {
+        this->HasFloat128 = true;
+      }
+    }
+  }
+
+  const char *getStaticInitSectionSpecifier() const override {
+    return ".text.startup";
+  }
+};
+
 } // namespace targets
 } // namespace clang
 #endif // LLVM_CLANG_LIB_BASIC_TARGETS_OSTARGETS_H
diff --git a/clang/lib/Driver/CMakeLists.txt b/clang/lib/Driver/CMakeLists.txt
index a6bd2d41e..fe9f559bb 100644
--- a/clang/lib/Driver/CMakeLists.txt
+++ b/clang/lib/Driver/CMakeLists.txt
@@ -78,6 +78,7 @@ add_clang_library(clangDriver
   ToolChains/NetBSD.cpp
   ToolChains/OHOS.cpp
   ToolChains/OpenBSD.cpp
+  ToolChains/Playbit.cpp
   ToolChains/PS4CPU.cpp
   ToolChains/RISCVToolchain.cpp
   ToolChains/Solaris.cpp
diff --git a/clang/lib/Driver/Driver.cpp b/clang/lib/Driver/Driver.cpp
index bdbdad936..7b0ebc0a9 100644
--- a/clang/lib/Driver/Driver.cpp
+++ b/clang/lib/Driver/Driver.cpp
@@ -43,6 +43,7 @@
 #include "ToolChains/NetBSD.h"
 #include "ToolChains/OHOS.h"
 #include "ToolChains/OpenBSD.h"
+#include "ToolChains/Playbit.h"
 #include "ToolChains/PPCFreeBSD.h"
 #include "ToolChains/PPCLinux.h"
 #include "ToolChains/PS4CPU.h"
@@ -6267,6 +6268,9 @@ const ToolChain &Driver::getToolChain(const ArgList &Args,
         break;
       }
       break;
+    case llvm::Triple::Playbit:
+      TC = std::make_unique<toolchains::Playbit>(*this, Target, Args);
+      break;
     case llvm::Triple::PS4:
       TC = std::make_unique<toolchains::PS4CPU>(*this, Target, Args);
       break;
diff --git a/clang/lib/Driver/ToolChains/Gnu.cpp b/clang/lib/Driver/ToolChains/Gnu.cpp
index 40038dce4..f902258a3 100644
--- a/clang/lib/Driver/ToolChains/Gnu.cpp
+++ b/clang/lib/Driver/ToolChains/Gnu.cpp
@@ -404,6 +404,8 @@ void tools::gnutools::Linker::ConstructJob(Compilation &C, const JobAction &JA,
   // handled somewhere else.
   Args.ClaimAllArgs(options::OPT_w);
 
+  printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
+
   if (!D.SysRoot.empty())
     CmdArgs.push_back(Args.MakeArgString("--sysroot=" + D.SysRoot));
 
@@ -433,6 +435,8 @@ void tools::gnutools::Linker::ConstructJob(Compilation &C, const JobAction &JA,
     CmdArgs.push_back(Arch == llvm::Triple::aarch64_be ? "-EB" : "-EL");
   }
 
+  printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
+
   // Most Android ARM64 targets should enable the linker fix for erratum
   // 843419. Only non-Cortex-A53 devices are allowed to skip this flag.
   if (Arch == llvm::Triple::aarch64 && (isAndroid || isOHOSFamily)) {
@@ -441,19 +445,27 @@ void tools::gnutools::Linker::ConstructJob(Compilation &C, const JobAction &JA,
       CmdArgs.push_back("--fix-cortex-a53-843419");
   }
 
+  printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
+
   ToolChain.addExtraOpts(CmdArgs);
 
-  CmdArgs.push_back("--eh-frame-hdr");
+  printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
 
+  CmdArgs.push_back("--eh-frame-hdr");
+printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
   if (const char *LDMOption = getLDMOption(ToolChain.getTriple(), Args)) {
+    printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
     CmdArgs.push_back("-m");
     CmdArgs.push_back(LDMOption);
   } else {
+    printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
     D.Diag(diag::err_target_unknown_triple) << Triple.str();
     return;
   }
+  printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
   if (Triple.isRISCV())
     CmdArgs.push_back("-X");
+  printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
 
   if (Args.hasArg(options::OPT_shared))
     CmdArgs.push_back("-shared");
@@ -582,8 +594,12 @@ void tools::gnutools::Linker::ConstructJob(Compilation &C, const JobAction &JA,
     CmdArgs.push_back("-lm");
   }
 
+  printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
+
   if (!Args.hasArg(options::OPT_nostdlib, options::OPT_r)) {
+    printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
     if (!Args.hasArg(options::OPT_nodefaultlibs)) {
+      printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
       if (IsStatic || IsStaticPIE)
         CmdArgs.push_back("--start-group");
 
@@ -609,7 +625,9 @@ void tools::gnutools::Linker::ConstructJob(Compilation &C, const JobAction &JA,
         // FIXME: Does this really make sense for all GNU toolchains?
         WantPthread = true;
 
+      printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
       AddRunTimeLibs(ToolChain, D, CmdArgs, Args);
+      printf("[pb] trace %s:%d\n", __FILE__, __LINE__);
 
       // LLVM support for atomics on 32-bit SPARC V8+ is incomplete, so
       // forcibly link with libatomic as a workaround.
diff --git a/clang/lib/Driver/ToolChains/WebAssembly.cpp b/clang/lib/Driver/ToolChains/WebAssembly.cpp
index 36bed3166..a5b7e6208 100644
--- a/clang/lib/Driver/ToolChains/WebAssembly.cpp
+++ b/clang/lib/Driver/ToolChains/WebAssembly.cpp
@@ -20,6 +20,8 @@
 #include "llvm/Support/Path.h"
 #include "llvm/Support/VirtualFileSystem.h"
 
+#include <iostream>
+
 using namespace clang::driver;
 using namespace clang::driver::tools;
 using namespace clang::driver::toolchains;
@@ -50,8 +52,10 @@ std::string wasm::Linker::getLinkerPath(const ArgList &Args) const {
             << A->getAsString(Args);
     }
   }
-
-  return ToolChain.GetProgramPath(ToolChain.getDefaultLinker());
+  const char* defaultLinker = ToolChain.getDefaultLinker();
+  if (llvm::sys::path::is_absolute(defaultLinker))
+    return defaultLinker;
+  return ToolChain.GetProgramPath(defaultLinker);
 }
 
 void wasm::Linker::ConstructJob(Compilation &C, const JobAction &JA,
@@ -177,8 +181,30 @@ WebAssembly::WebAssembly(const Driver &D, const llvm::Triple &Triple,
 
   getProgramPaths().push_back(getDriver().getInstalledDir());
 
-  auto SysRoot = getDriver().SysRoot;
+  std::string SysRoot = getDriver().SysRoot;
+
+  std::cout << "[wasm] default sysroot: " << SysRoot << std::endl;
+  std::cout << "[wasm] triple: " << getTriple().str() << std::endl;
+
   if (getTriple().getOS() == llvm::Triple::UnknownOS) {
+    // if no explicit --sysroot argument is given, use the default sysroot
+    if (!Args.hasArg(options::OPT__sysroot_EQ)) {
+      const char* exedir = getDriver().getInstalledDir();
+      SysRoot = std::string(exedir, (size_t)(uintptr_t)(strrchr(exedir, '/') - exedir));
+      if (getTriple().isArch64Bit()) {
+        SysRoot += "/sysroot-wasm64";
+      } else {
+        SysRoot += "/sysroot-wasm32";
+      }
+      std::cout << "[wasm] using default sysroot " << SysRoot << std::endl;
+    }
+    if (const Arg *A = Args.getLastArg(options::OPT__sysroot_EQ)) {
+      std::string sysroot = A->getValue();
+      std::cout << "[wasm] custom sysroot: " << sysroot << std::endl;
+    } else {
+      std::cout << "[wasm] custom sysroot: (none)" << std::endl;
+    }
+
     // Theoretically an "unknown" OS should mean no standard libraries, however
     // it could also mean that a custom set of libraries is in use, so just add
     // /lib to the search path. Disable multiarch in this case, to discourage
diff --git a/compiler-rt/lib/builtins/CMakeLists.txt b/compiler-rt/lib/builtins/CMakeLists.txt
index d62fa0432..73411382d 100644
--- a/compiler-rt/lib/builtins/CMakeLists.txt
+++ b/compiler-rt/lib/builtins/CMakeLists.txt
@@ -898,7 +898,7 @@ endif()
 # TODO: COMPILER_RT_BUILD_CRT used to be a cached variable so we need to unset
 # it first so cmake_dependent_option can set the local variable of the same
 # name. This statement can be removed in the future.
-unset(COMPILER_RT_BUILD_CRT CACHE)
+#unset(COMPILER_RT_BUILD_CRT CACHE)
 
 cmake_dependent_option(COMPILER_RT_BUILD_CRT "Build crtbegin.o/crtend.o" ON "COMPILER_RT_HAS_CRT" OFF)
 
diff --git a/llvm/include/llvm/TargetParser/Triple.h b/llvm/include/llvm/TargetParser/Triple.h
index 79ccd644a..f97a2b1b9 100644
--- a/llvm/include/llvm/TargetParser/Triple.h
+++ b/llvm/include/llvm/TargetParser/Triple.h
@@ -225,7 +225,8 @@ public:
     Emscripten,
     ShaderModel, // DirectX ShaderModel
     LiteOS,
-    LastOSType = LiteOS
+    Playbit,
+    LastOSType = Playbit
   };
   enum EnvironmentType {
     UnknownEnvironment,
diff --git a/llvm/lib/TargetParser/Triple.cpp b/llvm/lib/TargetParser/Triple.cpp
index a3d6a06af..c8a5d0802 100644
--- a/llvm/lib/TargetParser/Triple.cpp
+++ b/llvm/lib/TargetParser/Triple.cpp
@@ -245,6 +245,7 @@ StringRef Triple::getOSTypeName(OSType Kind) {
   case ZOS: return "zos";
   case ShaderModel: return "shadermodel";
   case LiteOS: return "liteos";
+  case Playbit: return "playbit";
   }
 
   llvm_unreachable("Invalid OSType");
@@ -601,6 +602,7 @@ static Triple::OSType parseOS(StringRef OSName) {
     .StartsWith("cuda", Triple::CUDA)
     .StartsWith("nvcl", Triple::NVCL)
     .StartsWith("amdhsa", Triple::AMDHSA)
+    .StartsWith("playbit", Triple::Playbit)
     .StartsWith("ps4", Triple::PS4)
     .StartsWith("ps5", Triple::PS5)
     .StartsWith("elfiamcu", Triple::ELFIAMCU)
